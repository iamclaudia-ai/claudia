#!/usr/bin/env bun

/**
 * Generate API Reference — config-driven
 *
 * Reads extension IDs from claudia.example.json, dynamically imports each
 * extension's default export to get its method definitions. Gateway methods
 * come from the canonical BUILTIN_METHODS export (no duplication).
 */

import { zodToJsonSchema } from "zod-to-json-schema";
import { writeFileSync, readFileSync } from "node:fs";
import { join } from "node:path";
import type { ZodTypeAny } from "zod";
import type { ClaudiaExtension } from "@claudia/shared";
import { BUILTIN_METHODS } from "../packages/gateway/src/methods";

const ROOT = join(import.meta.dir, "..");

type MethodDef = {
  method: string;
  description: string;
  inputSchema: ZodTypeAny;
  source: "gateway" | "extension";
};

function requiredOptional(schema: ZodTypeAny): { required: string[]; optional: string[] } {
  const json = zodToJsonSchema(schema, "schema") as {
    definitions?: { schema?: { properties?: Record<string, unknown>; required?: string[] } };
  };
  const root = json.definitions?.schema;
  const props = Object.keys(root?.properties || {});
  const req = new Set(root?.required || []);
  return {
    required: props.filter((p) => req.has(p)),
    optional: props.filter((p) => !req.has(p)),
  };
}

function methodRows(methods: MethodDef[]): string {
  const sorted = [...methods].sort((a, b) => a.method.localeCompare(b.method));
  const rows = sorted.map((m) => {
    const io = requiredOptional(m.inputSchema);
    const required = io.required.length ? io.required.map((p) => `\`${p}\``).join(", ") : "none";
    const optional = io.optional.length ? io.optional.map((p) => `\`${p}\``).join(", ") : "none";
    return `| \`${m.method}\` | ${required} | ${optional} | ${m.description} |`;
  });
  return [
    "| Method | Required Params | Optional Params | Description |",
    "| --- | --- | --- | --- |",
    ...rows,
  ].join("\n");
}

// ── Gateway methods — imported directly, no duplication ──────────
const gatewayMethods: MethodDef[] = BUILTIN_METHODS.map((m) => ({
  ...m,
  source: "gateway" as const,
}));

// ── Extension methods — discovered from claudia.example.json ─────
function getExtensionIdsFromConfig(): string[] {
  const raw = readFileSync(join(ROOT, "claudia.example.json"), "utf-8");
  // Strip JSON5 single-line comments — but only when NOT inside a string.
  // Walk char-by-char to handle "ws://..." URLs safely.
  let stripped = "";
  let inString = false;
  let escape = false;
  for (let i = 0; i < raw.length; i++) {
    const ch = raw[i];
    if (escape) {
      stripped += ch;
      escape = false;
      continue;
    }
    if (ch === "\\" && inString) {
      stripped += ch;
      escape = true;
      continue;
    }
    if (ch === '"') {
      inString = !inString;
      stripped += ch;
      continue;
    }
    if (!inString && ch === "/" && raw[i + 1] === "/") {
      // Skip to end of line
      while (i < raw.length && raw[i] !== "\n") i++;
      stripped += "\n";
      continue;
    }
    stripped += ch;
  }
  const config = JSON.parse(stripped) as { extensions?: Record<string, unknown> };
  return Object.keys(config.extensions || {});
}

async function loadExtensionMethods(): Promise<MethodDef[]> {
  const extensionIds = getExtensionIdsFromConfig();
  const out: MethodDef[] = [];

  for (const id of extensionIds) {
    const entryPath = join(ROOT, "extensions", id, "src", "index.ts");

    try {
      const mod = await import(entryPath);
      const factory = mod.default as (() => ClaudiaExtension) | undefined;

      if (!factory || typeof factory !== "function") {
        console.warn(`[warn] extensions/${id}: no default export factory — skipping`);
        continue;
      }

      const ext = factory();
      for (const method of ext.methods) {
        out.push({
          method: method.name,
          description: method.description,
          inputSchema: method.inputSchema,
          source: "extension",
        });
      }
      console.log(`[ok]   ${id}: ${ext.methods.length} methods`);
    } catch (err) {
      console.warn(`[skip] extensions/${id}: ${err instanceof Error ? err.message : err}`);
    }
  }

  return out;
}

// ── Generate ─────────────────────────────────────────────────────
const extensionMethods = await loadExtensionMethods();

const content = `# Claudia API Reference

This file is generated by \`scripts/generate-api-reference.ts\`.

## Gateway API (port 30086, \`/ws\`)

${methodRows(gatewayMethods)}

## Extension API (via gateway)

${methodRows(extensionMethods)}

## Notes

- Multi-word methods use snake_case (for example \`session.get_or_create_workspace\`, \`session.send_tool_result\`).
- Source of truth is the code and schemas; regenerate after API changes.
`;

writeFileSync(join(ROOT, "docs", "API-REFERENCE.md"), content);
console.log("\n[docs] Wrote docs/API-REFERENCE.md");
